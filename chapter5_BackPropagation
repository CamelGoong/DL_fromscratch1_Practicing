# 곱셈 계층의 구현
class MulLayer:

  # 인스턴스 변수 초기화
  def __init__(self):
    self.x = None
    self.y = None

  def forward(self, x, y):
    self.x = x
    self.y = y
    out = x*y

    return out

  def backward(self, dout):
    dx = dout * self.y
    dy = dout * self.x

    return dx, dy
# 사과 2개 구입하는 예제풀이

# 처음에 주어진 수치 설정
apple = 100
apple_num = 2
tax = 1.1

# 계층들 인스턴스화
mul_apple_layer = MulLayer()
mul_tax_layer = MulLayer()

# 순전파
apple_price = mul_apple_layer.forward(apple, apple_num)
price = mul_tax_layer.forward(apple_price, tax)

print(price)

# 역전파
dprice = 1 # 초기 미분값은 자신에 대한 미분이니까 1.
dapple_price, dtax = mul_tax_layer.backward(dprice)
dapple, dapple_num = mul_apple_layer.backward(dapple_price)

print(dapple, dapple_num, dtax) 

class AddLayer:
  def __init__(self):
    pass
  
  def forward(self, x, y):
    out = x + y

    return out

  def backward(self, dout):
    dx = dout * 1
    dy = dout * 1

    return dx, dy

# 그림 5-17 예제 풀이

# 예제 데이터
apple_num = 2
apple = 100

orange_num = 3
orange = 150

tax = 1.1

# 계층들 인스턴스화
mul_apple_layer = MulLayer()
mul_orange_layer = MulLayer()
add_apple_orange_layer = AddLayer()
mul_tax_layer = MulLayer()

# 순전파
apple_price = mul_apple_layer.forward(apple_num, apple)
orange_price = mul_orange_layer.forward(orange_num, orange)

apple_orange_price = add_apple_orange_layer.forward(apple_price,orange_price)

price = mul_tax_layer.forward(apple_orange_price, tax)


# 역전파
dprice = 1
dall_price, dtax = mul_tax_layer.backward(dprice)
dapple_price, dorange_price = add_apple_orange_layer.backward(dall_price)
dapple, dapple_num = mul_apple_layer.backward(dapple_price)
dorange, dorange_num = mul_orange_layer.backward(dorange_price)

# 결과 출력
print(price)
print(dapple, dapple_num, dorange, dorange_num, dtax)

# ReLU 함수 구현
class Relu:
  def __init__(self):
    self.mask = None # 추후에 역전파 때, x>0, x<=0에 대해서 다른 값을 적용하기 위해서 boolean값을 저장하는 변수!
  def forward(self, x):
    self.mask = (x <= 0) # self.mask 인스턴스 변수에다가 입력되는 인수(배열)의 각 원소에 대해서 0이하인 것에 대해서만 True를 반환하는 배열을 입력
    out = x.copy() # x 배열을 복사
    out[self.mask] = 0

    return out
  def backword(self, dout):
    dout[self.mask] = 0
    dx = dout

    return dx
# sigmoid 계층 구현
class Sigmoid:
  def __init__(self):
    self.out = None # backward() 과정에서 출력값인 y(out)이 쓰이니까, 이를 미리 저장해놓는 것.
  
  def forward(self, x):
    out = 1 / (1 + np.exp(-x))
    self.out = out # 여기서 순전파 최종 출력값인 out을 saved

    return out

  def backward(self, dout):
    dx = dout * self.out(1.0 - self.out) * self.out

    return dx
# 순전파 떄, 편향 덧셈에 유의
import numpy as np

X_dot_W = np.array([[0,0,0], [10,10,10]])
B = np.array([1, 2, 3])
print(X_dot_W + B)

dY = np.array([[1,2,3], [4,5,6]])
print(dY)

dB = np.sum(dY, axis = 0)
print(dB)

# Affine 구현
class Affine:
  def __init__(self, W, b):
    self.W = W
    self.b = b
    self.x = None
    self.dW = None
    self.dB = None
  
  def forward(self, x):
    self.x = x
    out = np.dot(x, self.w) + self.b

    return out

  def backward(self, dout):
    dx = np.dot(dout, self.w.T)
    self.dW = np.dot(self.x.T, dout)
    self.dB = np.sum(dout, axis = 0)

    return dx
